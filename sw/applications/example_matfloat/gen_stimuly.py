#!/usr/bin/env python

## Copyright 2024 EPFL
## Solderpad Hardware License, Version 2.1, see LICENSE.md for details.
## SPDX-License-Identifier: Apache-2.0 WITH SHL-2.1

import sys
import random
import numpy as np

def write_vec(f, name, arr, ctype="float", size=None):

    # If size not given, infer it
    if size is None:
        size = len(arr) if hasattr(arr, "__len__") else 1

    # Scalar case
    if size == 1:
        f.write(f"const {ctype} {name} = {float(arr):.6f}f;\n")

    # Vector/array case
    else:
        f.write(f"const {ctype} {name}[{size}] = {{\n")

        for elem in arr:
            f.write(f"    {float(elem):.6f}f,\n")

        f.write("};\n\n")

################################################################################

f = open('matfloat.h', 'w')
f.write('#ifndef _MATFLOAT_\n')
f.write('#define _MATFLOAT_\n')
f.write('// This file is automatically generated\n')

SIZE  = 32

vecA = np.random.uniform(0.0, 1.0, SIZE).astype(np.float32)
vecB = np.random.uniform(0.0, 1.0, SIZE).astype(np.float32)

# Round to 4 decimal digits
vecA = np.round(vecA, 4)
vecB = np.round(vecB, 4)

# Element-wise sum
vecSum = vecA + vecB

# Dot product
dot = np.dot(vecA, vecB)

write_vec(f, 'vec_a',   vecA, 'float', SIZE)
write_vec(f, 'vec_b',   vecB, 'float', SIZE)
write_vec(f, 'vec_sum',   vecSum, 'float', SIZE)
write_vec(f, 'dot_exp', dot, 'float', 1)

f.write('#define SIZE %d\n' % SIZE)
f.write('#endif')
f.close()
